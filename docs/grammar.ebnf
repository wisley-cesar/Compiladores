(* Gramática EBNF usada pelo parser deste projeto. *)

(* Observações relevantes:
   - O parser é manual (recursivo-descendente) e aceita declarações de variável
     com inicializador opcional (ex.: `int x = 1;`).
   - O parser aceita declarações em qualquer posição (top-level ou dentro de blocos).
     A política de uso/declaração (declare-before-use) é aplicada pelo analisador semântico
     para variáveis locais; existe uma etapa opcional de pré-varredura para declarações
     top-level se desejado.
   - Comentários (//, /* */) e espaços são ignorados pelo lexer.
*)

program ::= { declaration_or_statement } ;

(* O parser aceita uma sequência arbitrária de declarações e statements;
  isto cobre tanto o caso Gramática: Programa -> Declarações Comandos
  quanto o estilo permissivo (declarações intercaladas). *)

declaration_or_statement ::= declaration | statement ;

functionDecl  ::= 'public'? 'static'? type IDENT '(' [ paramList ] ')' block ;
paramList     ::= param { ',' param } ;
param         ::= type IDENT ;

(* Declaração de variável: suportamos tipo explícito ou a keyword especial `uids`
  (inferência). Inicializador é opcional — o analisador semântico fará checagens
  de compatibilidade de tipo e possíveis avisos de coerção. *)
varDecl ::= type IDENT [ '=' expression ] ';' | 'uids' IDENT [ '=' expression ] ';' ;

// Tipos básicos
type ::= 'int' | 'float' | 'double' | 'string' | 'bool' ;

// Blocos e statements
block ::= '{' { declaration_or_statement } '}' ;

statement ::= block
            | ifStmt
            | whileStmt
            | forStmt
            | returnStmt
            | exprStmt
            | varDecl
            | ';' ;

ifStmt ::= 'if' '(' expression ')' statement [ 'else' statement ] ;
whileStmt ::= 'while' '(' expression ')' statement ;
forStmt ::= 'for' '(' [ forInit ] ';' [ expression ] ';' [ expression ] ')' statement ;
forInit ::= varDecl | exprStmt ;
returnStmt ::= 'return' [ expression ] ';' ;
exprStmt ::= expression ';' ;

// Expressões (esqueleto com precedência sugerida)
expression ::= assignment ;

assignment ::= conditional [ ( '=' | '+=' | '-=' | '*=' | '/=' ) assignment ] ;

conditional ::= logical_or [ '?' expression ':' conditional ] ;

logical_or ::= logical_and { '||' logical_and } ;
logical_and ::= equality { '&&' equality } ;

equality ::= relational { ( '==' | '!=' ) relational } ;

relational ::= additive { ( '<' | '>' | '<=' | '>=' ) additive } ;

additive ::= multiplicative { ( '+' | '-' ) multiplicative } ;

multiplicative ::= unary { ( '*' | '/' | '%' ) unary } ;

unary ::= ( '+' | '-' | '!' ) unary | primary ;

primary ::= literal | IDENT | '(' expression ')' ;

argList ::= expression { ',' expression } ;

literal ::= NUMBER | STRING | 'true' | 'false' ;

// -----------------------------------------------------------------------------
// Lexical (tokens) - definir no lexer
// -----------------------------------------------------------------------------
// IDENT  : letter ( letter | digit | '_' )*
// NUMBER : digit+ ('.' digit+)? ([eE] [+-]? digit+)?
// STRING : '"' ( escape | ~('"'|'\\') )* '"'
// letter : [a-zA-Z_]
// digit  : [0-9]
//
// Símbolos e operadores reconhecidos (verificar em lexical_definitions.dart):
// OPERADORES: + - * / % = == != < > <= >= && || ! ++ -- += -= *= /= & | ^ ~ << >> >>> >>= <<= =>
// SIMBOLOS: ( ) { } [ ] ; , . : ? ->
// Palavras reservadas (exemplos extraídas do projeto):
// if else while for do break continue int float double string bool char return void main true false null
// class public private static final import package new this super

// Comentários:
//  LINE_COMMENT : '//' .*? '\n'
//  BLOCK_COMMENT: '/*' .*? '*/'   (atenção para comentário não fechado)

// Espaçamento (ignorados): whitespace = ( ' ' | '\t' | '\r' | '\n' )+

// -----------------------------------------------------------------------------
// Exemplos de trechos válidos (para testes):
// int x = 10;
// float y = 3.14e-2;
// string s = "Hello\nWorld";
// if (x > 0) { x = x - 1; }
// for (int i = 0; i < 10; i++) { print(i); }
// -----------------------------------------------------------------------------

(* Fim da gramática *)
